import { vi } from "vitest";
import { ref, computed } from "vue";
import { mockSupabaseClient } from "../setup"; // Import mockSupabaseClient

/**
 * Type definitions for improved type safety
 */
type SupabaseQueryBuilder = {
  select: ReturnType<typeof vi.fn>;
  insert: ReturnType<typeof vi.fn>;
  update: ReturnType<typeof vi.fn>;
  delete: ReturnType<typeof vi.fn>;
  upsert: ReturnType<typeof vi.fn>;
  eq: ReturnType<typeof vi.fn>;
  in: ReturnType<typeof vi.fn>;
  match: ReturnType<typeof vi.fn>;
  single: ReturnType<typeof vi.fn>;
  order: ReturnType<typeof vi.fn>;
  limit: ReturnType<typeof vi.fn>;
  then: ReturnType<typeof vi.fn>;
  data: any | null;
  error: any | null;
};

type SupabaseResponse = { data: any | null; error: any | null };

type MockHttpMethod = ReturnType<typeof vi.fn>;

type FetchMock = ReturnType<typeof vi.fn> & {
  raw: ReturnType<typeof vi.fn>;
  create: ReturnType<typeof vi.fn>;
  get: MockHttpMethod;
  post: MockHttpMethod;
  put: MockHttpMethod;
  delete: MockHttpMethod;
};

type SupabaseUser = {
  id: string;
  email?: string;
};

/**
 * Mock for $fetch with better request handling and response structure
 */
export const mockFetch = vi.fn((url: string | Request, options?: any) => {
  const urlString = typeof url === "string" ? url : url.url;
  const method = options?.method?.toLowerCase() || "get";

  if (method === "post" && mockFetch.post) {
    return mockFetch.post(urlString, options);
  }
  if (method === "get" && mockFetch.get) {
    return mockFetch.get(urlString, options);
  }

  return Promise.resolve({
    json: () =>
      Promise.resolve({ message: "Default mock response (direct call)" }),
    text: () => Promise.resolve("Default mock text (direct call)"),
    ok: true,
    status: 200,
    statusText: "OK",
  });
}) as FetchMock;

mockFetch.get = vi.fn((url: string, options?: any) => {
  return Promise.resolve({
    json: () => Promise.resolve({ message: "Default mock GET response" }),
    text: () => Promise.resolve("Default mock GET text"),
    ok: true,
    status: 200,
    statusText: "OK",
  });
});

mockFetch.post = vi.fn((url: string, options?: any) => {
  if (url.includes("/api/ai/runAnalysis")) {
    const analysisKey = options?.body?.analysisKey;
    if (analysisKey === "reportGeneration") {
      return Promise.resolve({
        json: () =>
          Promise.resolve({
            analyzedData: {
              title: "Mocked Report Title",
              summary: "Mocked summary generated by AI",
            },
            processInputError: null,
            outputData: {},
          }),
        ok: true,
        status: 200,
        statusText: "OK",
      });
    }
    if (analysisKey === "refineProblemStatement") {
      return Promise.resolve({
        json: () =>
          Promise.resolve({
            analyzedData: {
              title: "Mocked AI refined problem statement",
              description: "Mocked AI refined problem statement",
              recommendations: ["Mocked recommendation"],
            },
            processInputError: null,
            outputData: {},
          }),
        ok: true,
        status: 200,
        statusText: "OK",
      });
    }
    if (analysisKey === "empathyMapAnalysis") {
      return Promise.resolve({
        json: () =>
          Promise.resolve({
            analysis: {
              says: ["Mocked says"],
              thinks: ["Mocked thinks"],
              does: ["Mocked does"],
              feels: ["Mocked feels"],
            },
            processInputError: null,
            outputData: {},
          }),
        ok: true,
        status: 200,
        statusText: "OK",
      });
    }
    // Outros analysisKey podem ser tratados aqui conforme necessidade
  }
  if (url.includes("/api/ai/generate")) {
    return Promise.resolve({
      generatedText: "Mocked AI generated content",
      status: 200,
      statusText: "OK",
    });
  }
  return Promise.resolve({
    json: () => Promise.resolve({ message: "Default mock POST response" }),
    text: () => Promise.resolve("Default mock POST text"),
    ok: true,
    status: 200,
    statusText: "OK",
  });
});

mockFetch.put = vi.fn();
mockFetch.delete = vi.fn();

mockFetch.raw = vi.fn().mockResolvedValue({
  data: "mock raw response",
  status: 200,
  statusText: "OK",
});

mockFetch.create = vi.fn().mockReturnValue(mockFetch);

/**
 * Creates a chainable Supabase query builder mock
 */
function createQueryBuilderMock(defaultData: any = null): SupabaseQueryBuilder {
  const builder = {} as SupabaseQueryBuilder;
  const chainableMethods = [
    "select",
    "insert",
    "update",
    "delete",
    "upsert",
    "eq",
    "in",
    "match",
    "order",
    "limit",
  ];

  chainableMethods.forEach((method) => {
    builder[method as keyof SupabaseQueryBuilder] = vi
      .fn()
      .mockReturnValue(builder); // Fixed: Assert method as keyof SupabaseQueryBuilder
  });

  builder.single = vi.fn().mockResolvedValue({
    data: defaultData,
    error: null,
  });

  builder.then = vi.fn((cb) =>
    Promise.resolve(cb({ data: defaultData, error: null }))
  );

  return builder;
}

/**
 * Complete mock for Nuxt/Vue/Supabase imports
 */
const internalImportsMock = {
  // Supabase authentication mocks
  useSupabaseUser: () => ({
    value: {
      id: "test-user-id",
      email: "test@example.com",
    } as SupabaseUser,
  }),

  // Supabase client with comprehensive mocking
  useSupabaseClient: () => mockSupabaseClient, // Use the imported mockSupabaseClient

  // Nuxt specific mocks
  $fetch: mockFetch, // mockFetch is already defined in this file

  useRuntimeConfig: () => ({
    public: {
      supabase: {
        url: "https://test-supabase-url.com",
        key: "test-supabase-key",
      },
      apiBaseUrl: "https://test-api-url.com",
      aiApiKey: "test-ai-api-key",
    },
    app: {}, // app property is present
  }),

  defineNuxtPlugin: vi.fn((pluginFn) => pluginFn),
  addRouteMiddleware: vi.fn(),
  defineNuxtRouteMiddleware: vi.fn((middlewareFn) => middlewareFn),
  navigateTo: vi.fn(),

  useAsyncData: vi.fn((key, handler) => {
    const result = handler ? handler() : null;
    return Promise.resolve({
      data: ref(result),
      error: ref(null),
      pending: ref(false),
      refresh: vi.fn(),
      execute: vi.fn().mockResolvedValue(result),
    });
  }),

  useFetch: vi.fn((url, options) => {
    return Promise.resolve({
      data: ref({ message: "Mock useFetch response" }),
      error: ref(null),
      pending: ref(false),
      refresh: vi.fn(),
      execute: vi.fn(),
    });
  }),

  useHead: vi.fn(),
  useCookie: vi.fn((name?: string, opts?: any) => ref(null)),
  useRequestEvent: vi.fn(() => undefined),
  definePageMeta: vi.fn((meta: any) => meta),
  useState: vi.fn((key: string, init?: () => any) =>
    ref(init ? init() : undefined)
  ), // Added

  // Add mocks for other stores as needed
  useProjectStore: vi.fn(() => ({
    projects: ref([
      { id: 1, name: "Test Project 1", description: "Test description 1" },
      { id: 2, name: "Test Project 2", description: "Test description 2" },
    ]),
    loading: ref(false),
    error: ref(null),
    fetchProjects: vi.fn().mockResolvedValue([]),
    createProject: vi.fn().mockResolvedValue({ id: 3 }),
    updateProject: vi.fn().mockResolvedValue(true),
    deleteProject: vi.fn().mockResolvedValue(true),
  })),

  taskFlowStoreFactoryInternal: () => {
    // Renamed for clarity, will be wrapped
    const currentTaskId = ref<string | null>(null);
    const nodes = ref<any[]>([]); // Replace 'any' with your TaskFlowNode type if available here
    const edges = ref<any[]>([]); // Replace 'any' with your TaskFlowEdge type if available here
    const viewport = ref({ x: 0, y: 0, zoom: 1 });
    const loadingStates = ref<
      Record<string, { isLoading: boolean; message: string }>
    >({});
    const empathMapLastProcessedInputs = ref<Record<string, string | null>>({});
    const reportLastProcessedInputs = ref<Record<string, string | null>>({}); // Added for report card
    const isInitialLoadComplete = ref(false);

    // Mock common actions - add more as needed by your tests
    const addNode = vi.fn((nodeToAdd: any) => {
      // Modify addNode
      nodes.value.push(nodeToAdd);
      return Promise.resolve(undefined); // Keep promise if original is async
    });
    const removeNode = vi.fn().mockResolvedValue(undefined);
    const addEdge = vi.fn().mockResolvedValue(undefined);
    const removeEdge = vi.fn().mockResolvedValue(undefined);
    const updateNodeData = vi.fn((nodeId: string, newData: any) => {
      // Modify updateNodeData
      const nodeIndex = nodes.value.findIndex((n) => n.id === nodeId);
      if (nodeIndex !== -1) {
        // Ensure we are updating the 'data' property of the node,
        // and merging if newData is partial.
        // The 'result' from processInput is the new 'data' object.
        nodes.value[nodeIndex].data = {
          ...nodes.value[nodeIndex].data,
          ...newData,
        };
      }
      return Promise.resolve(undefined);
    });
    const loadTaskFlow = vi.fn().mockImplementation(async (taskId: string) => {
      currentTaskId.value = taskId;
      nodes.value = []; // Reset or load mock data
      edges.value = [];
      isInitialLoadComplete.value = true;
      return Promise.resolve();
    });
    const saveTaskFlow = vi.fn().mockResolvedValue(undefined);
    const processNodeInputs = vi.fn().mockResolvedValue(true);
    const propagateOutput = vi.fn().mockResolvedValue(undefined);
    const setEmpathMapLastProcessedInput = vi.fn();
    const getEmpathMapLastProcessedInput = vi.fn((nodeId: string) => {
      // Add this function
      return empathMapLastProcessedInputs.value[nodeId] || null;
    });
    const setReportLastProcessedInput = vi.fn(
      (nodeId: string, input: string | null) => {
        // Added for report card
        if (input === null) {
          delete reportLastProcessedInputs.value[nodeId];
        } else {
          reportLastProcessedInputs.value[nodeId] = input;
        }
      }
    );
    const getReportLastProcessedInput = vi.fn((nodeId: string) => {
      // Added for report card
      return reportLastProcessedInputs.value[nodeId] || null;
    });
    const requestNodeReprocessing = vi.fn().mockResolvedValue(undefined);
    const updateNodePosition = vi.fn();
    const createInitialNodeData = vi.fn(() => ({
      label: "",
      title: "",
      description: "",
      sources: [],
      inputData: {},
      outputData: {},
      cumulativeContext: { compressed: false, blob: {} },
      processInputError: null,
      updated_at: null,
    }));
    const clearEmpathMapAnalysis = vi.fn((nodeId: string) => {
      // Simulate the behavior of the actual store action
      // The actual store's setEmpathMapLastProcessedInput(nodeId, null) deletes the key.
      // The watcher's getEmpathMapLastProcessedInput returns primitive null if key doesn't exist.
      delete empathMapLastProcessedInputs.value[nodeId];

      // Also simulate clearing other relevant fields if the test relies on them
      const nodeIndex = nodes.value.findIndex((n) => n.id === nodeId);
      if (nodeIndex !== -1) {
        nodes.value[nodeIndex].data.analyzedData = null;
        nodes.value[nodeIndex].data.processInputError = null;
        nodes.value[nodeIndex].data.outputData = {};
      }
    });
    const clearReportAnalysis = vi.fn((nodeId: string) => {
      // Added for report card
      delete reportLastProcessedInputs.value[nodeId];
      const nodeIndex = nodes.value.findIndex((n) => n.id === nodeId);
      if (nodeIndex !== -1) {
        if (nodes.value[nodeIndex].data) {
          nodes.value[nodeIndex].data.analyzedData = null;
          nodes.value[nodeIndex].data.processInputError = null;
          nodes.value[nodeIndex].data.outputData = {};
        }
      }
    });

    return {
      currentTaskId,
      nodes,
      edges,
      viewport,
      loadingStates,
      empathMapLastProcessedInputs,
      reportLastProcessedInputs, // Added
      isInitialLoadComplete,
      addNode,
      removeNode,
      addEdge,
      removeEdge,
      updateNodeData,
      loadTaskFlow,
      saveTaskFlow,
      processNodeInputs,
      propagateOutput,
      setEmpathMapLastProcessedInput,
      getEmpathMapLastProcessedInput, // Expose it
      setReportLastProcessedInput, // Added
      getReportLastProcessedInput, // Added
      requestNodeReprocessing,
      updateNodePosition,
      createInitialNodeData,
      clearEmpathMapAnalysis, // Expose the new mock function
      clearReportAnalysis, // Added
      // Add other state/actions from the store that your components/tests might use
      // For example:
      // findNode: vi.fn((nodeId) => nodes.value.find(n => n.id === nodeId)),
      // getNodeHandler: vi.fn().mockReturnValue({ processInput: vi.fn().mockResolvedValue({}) }),
      getLoadingState: (nodeId: string) => {
        return loadingStates.value[nodeId];
      },
    };
  },
  // Now, create the vi.fn() instance using the factory, for export
  useTaskFlowStore: vi.fn(() =>
    internalImportsMock.taskFlowStoreFactoryInternal()
  ),

  // Vue-flow specific mocks if needed
  useVueFlow: vi.fn(() => ({
    nodes: ref([]),
    edges: ref([]),
    addNodes: vi.fn(),
    addEdges: vi.fn(),
    onNodeDragStop: vi.fn(),
    onConnect: vi.fn(),
    project: vi.fn(),
    getIntersectingNodes: vi.fn().mockReturnValue([]),
  })),
};

// Export each function individually for the #imports alias to work correctly
export const useSupabaseUser = internalImportsMock.useSupabaseUser;
export const useSupabaseClient = internalImportsMock.useSupabaseClient;

// Mocks for #supabase/server alias
export const serverSupabaseClient = vi
  .fn()
  .mockImplementation(() => mockSupabaseClient);
export const serverSupabaseUser = vi.fn().mockResolvedValue({
  id: "test-user-id",
  email: "test@example.com",
});
export const $fetch = internalImportsMock.$fetch;
export const useRuntimeConfig = internalImportsMock.useRuntimeConfig;
export const defineNuxtPlugin = internalImportsMock.defineNuxtPlugin;
export const addRouteMiddleware = internalImportsMock.addRouteMiddleware;
export const defineNuxtRouteMiddleware =
  internalImportsMock.defineNuxtRouteMiddleware;
export const navigateTo = internalImportsMock.navigateTo;
export const useAsyncData = internalImportsMock.useAsyncData;
export const useFetch = internalImportsMock.useFetch;
export const useHead = internalImportsMock.useHead;
export const useCookie = internalImportsMock.useCookie;
export const useRequestEvent = internalImportsMock.useRequestEvent;
export const definePageMeta = internalImportsMock.definePageMeta;
export const useState = internalImportsMock.useState;
export const useProjectStore = internalImportsMock.useProjectStore;
export const useTaskFlowStore = internalImportsMock.useTaskFlowStore; // Export the vi.fn() instance
export const taskFlowStoreFactory =
  internalImportsMock.taskFlowStoreFactoryInternal; // Keep factory export if needed elsewhere, but primary is useTaskFlowStore
export const useVueFlow = internalImportsMock.useVueFlow;

// Mock data for EmpathMapNodeHandler tests
export const createMockSurveyNode = (
  id: string,
  label: string,
  answers: any[]
) => ({
  id,
  type: "survey",
  data: {
    label,
    outputData: {
      survey_results: {
        submissions: answers.map((a, i) => ({
          submission_id: `sub-${id}-${i}`,
          answers: {
            "q-open-text": a.answer, // Assuming a generic open text question ID
          },
        })),
      },
      survey_structure: {
        "q-open-text": { type: "openText", id: "q-open-text" },
      },
    },
  },
});

export const createMockDataSourceNode = (
  id: string,
  label: string,
  files: any[]
) => ({
  id,
  type: "dataSource",
  data: {
    label,
    outputData: {
      uploaded_files: files.map((f, i) => ({
        id: `file-${id}-${i}`,
        category: f.category,
        content: f.content,
        inferred_survey_columns: f.inferred_survey_columns,
      })),
    },
  },
});

export const mockAnalysisResult = {
  says: ["Mock says 1", "Mock says 2"],
  thinks: ["Mock thinks 1", "Mock thinks 2"],
  does: ["Mock does 1", "Mock does 2"],
  feels: ["Mock feels 1", "Mock feels 2"],
};

// If there are other properties on importsMock that are not functions but are expected by Nuxt,
// they might need to be exported too, or the alias strategy might need further refinement.
// For now, focusing on the functions that are typically auto-imported.

// Keep the original importsMock export if it's used elsewhere directly,
// but the individual exports above are key for the #imports alias.
export const importsMock = internalImportsMock;
