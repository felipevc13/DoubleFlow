import type { INodeHandler } from "~/types/nodeHandler";
import type { NodeData, TaskFlowNode } from "~/types/taskflow"; // Adjust path if NodeData moves & Add TaskFlowNode
// Função utilitária local para calcular distribuição
function countDistribution(responses: any[]): Record<string, number> {
  const counts: Record<string, number> = {};
  for (const response of responses) {
    const v =
      response === null || response === undefined
        ? ""
        : String(response).trim();
    if (!v) continue;
    const options = v.split(",").map((opt) => opt.trim());
    for (const opt of options) {
      if (!opt) continue;
      counts[opt] = (counts[opt] || 0) + 1;
    }
  }
  return counts;
}

// Helper to ensure data consistency
function createInitialNodeData(config?: any): NodeData {
  return {
    label: config?.label || "Data Source",
    title: config?.title || "Dados do projeto",
    description:
      config?.description || "Provides data from the knowledge base.",
    sources: config?.selectedSourceIds || [], // Store IDs of selected sources if provided
    inputData: {},
    outputData: {}, // Generated by generateOutput
    cumulativeContext: { compressed: false, blob: {} },
    updated_at: new Date().toISOString(), // Add updated_at field
    // Add any other dataSource-specific default fields if needed
  };
}

export const dataSourceNodeHandler: INodeHandler = {
  initializeData(initialConfig?: any): NodeData {
    const data = createInitialNodeData(initialConfig);

    return data;
  },

  processInput(
    currentNodeData: NodeData,
    parentOutputs: Record<string, any>
  ): Record<string, any> {
    // <<< Correct return type

    // Data source nodes typically don't process inputs from parents.
    // Return the original inputData, not the whole NodeData object.
    return currentNodeData.inputData || {}; // Ensure it's always an object
  },

  generateOutput(currentNode: TaskFlowNode): Record<string, any> {
    const uploadedFiles = currentNode.data.sources || [];
    const allKpis: any[] = [];

    const outputFiles = uploadedFiles.map((file: any) => {
      if (typeof file === "string") {
        return {
          id: file,
          name: file,
          type: undefined,
          category: undefined,
          createdAt: undefined,
          content: undefined,
        };
      }

      if (file.type === "excel" && file.structured_data?.sheets) {
        const inferred_survey_columns: any[] = [];

        file.structured_data.sheets.forEach((sheet: any) => {
          if (!sheet.columns) return;
          sheet.columns.forEach((col: any) => {
            const responses = (col.responses || []).filter(
              (r: any) =>
                r !== null && r !== undefined && String(r).trim() !== ""
            );
            const distribution = countDistribution(responses);

            const colData: any = {
              questionText: col.header,
              questionType: col.type || "openText",
              totalResponses: responses.length,
            };

            if (Object.keys(distribution).length > 0) {
              colData.distribution = distribution;
            }
            if ((col.type || "openText") === "openText") {
              colData.openTextResponses = responses;
            }

            // KPI calculation for quantitative columns
            if (
              (col.type === "rating" || col.type === "opinionScale") &&
              responses.length > 0
            ) {
              const numericResponses = responses
                .map(Number)
                .filter((n: number) => !isNaN(n));
              if (numericResponses.length > 0) {
                const sum = numericResponses.reduce(
                  (a: number, b: number) => a + b,
                  0
                );
                const avg = sum / numericResponses.length;
                const kpi = {
                  metric: col.header,
                  value: avg.toFixed(1),
                  details: `N=${numericResponses.length} respostas`,
                  distribution,
                };
                colData.kpi = kpi;
                allKpis.push(kpi);
              }
            } else if (col.type === "multipleChoice" && responses.length > 0) {
              const mode = Object.entries(distribution).reduce(
                (a: [string, number], b: [string, number]) =>
                  b[1] > a[1] ? b : a,
                ["", 0]
              )[0];
              const kpi = {
                metric: col.header,
                value: mode,
                details: `N=${responses.length} respostas`,
                distribution,
              };
              colData.kpi = kpi;
              allKpis.push(kpi);
            }

            inferred_survey_columns.push(colData);
          });
        });

        return {
          ...file,
          inferred_survey_columns,
          createdAt: file.created_at || file.createdAt,
        };
      }
      return { ...file, createdAt: file.created_at || file.createdAt };
    });

    return {
      uploaded_files: outputFiles,
      survey_kpis: allKpis,
    };
  },

  // Optional: Format data for the card UI
  getDisplayData(currentNode: TaskFlowNode): any {
    // Assuming uploaded file info is stored in currentNode.data.sources
    const count = currentNode.data.sources?.length || 0;
    return {
      title: currentNode.data.title,
      sourceCount: count,
      // Display count of directly associated sources
    };
  },
};
