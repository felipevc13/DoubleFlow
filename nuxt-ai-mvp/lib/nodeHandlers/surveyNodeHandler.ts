import type { INodeHandler } from "~/types/nodeHandler";
import type { NodeData, TaskFlowNode } from "~/types/taskflow"; // NodeData is defined in types/taskflow
import { useSupabaseClient } from "#imports";
// import { useFetch } from "#app"; // Replaced with $fetch (usually auto-imported)

// --- Interfaces ---
// Optionally add responseCount to NodeData (if not already present in the type definition)
// Add this to the interface for context; remove if already present in NodeData elsewhere:
// interface NodeData {
//   ...
//   responseCount?: number;
// }
interface SurveyResults {
  responses: any[];
  summary?: Record<string, any>;
}

interface SurveyQuestion {
  id: string;
  question_text: string;
  question_type: string;
  // ... other question properties
}

interface SurveyStructureResponse {
  // For /api/surveys/:id/questions
  questions: SurveyQuestion[];
  // ... other survey properties like title, description
}

interface SurveyGenerationResponse {
  // For /api/ai/surveyGeneration
  survey_id: string;
  title?: string;
  // surveyStructure?: SurveyQuestion[]; // API might return initial structure too
}

// --- Helper ---
function createInitialNodeData(config?: any): NodeData {
  return {
    label: config?.label || "Survey",
    title: config?.title || "Define & Run Survey",
    description: config?.description || "Collect user feedback.",
    sources: [],
    inputData: {},
    outputData: {}, // Generated by generateOutput
    cumulativeContext: { compressed: false, blob: {} },
    surveyId: config?.surveyId || undefined,
    surveyStructure: config?.surveyStructure || undefined, // Store fetched structure
    updated_at: null, // Initialize to null, consistent with NodeData type and store's initializer
    processInputError: null, // Initialize to null, consistent with NodeData type
    is_active: config?.is_active ?? false, // Add is_active, default false if not provided
    responseCount: config?.responseCount ?? 0,
    // Add fields to store fetched results if needed, or rely on outputData
  };
}

export const surveyNodeHandler: INodeHandler = {
  // initializeData MUST be synchronous according to the interface
  initializeData(initialConfig?: any): NodeData {
    // Create basic structure. Async operations (generation, fetching)
    // should be triggered by the store via handleAction('initializeSurvey')
    // after the node is added.
    const data = createInitialNodeData(initialConfig);
    return data;
  },

  async processInput(
    currentNodeData: NodeData,
    parentOutputs: Record<string, any>,
    fetchInstance: typeof $fetch
  ): Promise<Record<string, any>> {
    // Checa se tem surveyId
    const surveyId = currentNodeData.surveyId;
    if (!surveyId) {
      return {
        outputData: {
          survey_results: { submissions: [] },
          survey_structure: [],
        },
        responseCount: 0,
      };
    }

    // 1. Busca submissions e status do survey
    let responses: any[] = [];
    let is_active = false;
    let surveyStructureToUse = currentNodeData.surveyStructure || [];
    try {
      // Endpoint de submissions
      const resultsResp = await fetchInstance<any>(
        `/api/surveys/${surveyId}/results`
      );
      if (Array.isArray(resultsResp?.submissions)) {
        responses = resultsResp.submissions;
      } else if (Array.isArray(resultsResp)) {
        responses = resultsResp;
      }

      // Endpoint de status
      const meta = await fetchInstance<{ is_active: boolean }>(
        `/api/surveys/${surveyId}`
      );
      is_active = !!meta?.is_active;
    } catch (e) {
      // Pode logar erro, mas não quebra o fluxo
    }

    // Busca estrutura se estiver vazia
    if (!surveyStructureToUse.length) {
      try {
        const structResp = await fetchInstance<{ questions: any[] }>(
          `/api/surveys/${surveyId}/questions`
        );
        surveyStructureToUse = structResp?.questions || [];
      } catch (e) {
        /* ignora erro */
      }
    }

    // 2. Calcula KPIs (pode externalizar esse helper se quiser)
    type KpiMetric = {
      metric: string;
      value: any;
      details?: string;
      distribution?: Record<string, number>;
      startLabel?: string;
      endLabel?: string;
    };
    function countDistribution(arr: any[]): Record<string, number> {
      const dist: Record<string, number> = {};
      for (const v of arr) {
        if (Array.isArray(v)) {
          for (const item of v) {
            dist[item] = (dist[item] || 0) + 1;
          }
        } else {
          dist[v] = (dist[v] || 0) + 1;
        }
      }
      return dist;
    }
    const survey_kpis: KpiMetric[] = [];
    for (const question of surveyStructureToUse) {
      const qType = question.type || question.question_type;
      const questionAnswers = responses
        .map((sub) => sub.answers?.[question.id])
        .filter(
          (a) => a !== undefined && a !== null && String(a).trim() !== ""
        );
      if (!questionAnswers.length) continue;
      if (qType === "rating" || qType === "opinionScale") {
        const numericResponses = questionAnswers
          .map(Number)
          .filter((n) => !isNaN(n));
        if (numericResponses.length) {
          const sum = numericResponses.reduce(
            (a: number, b: number) => a + b,
            0
          );
          const avg = sum / numericResponses.length;
          survey_kpis.push({
            metric: question.questionText,
            value: avg.toFixed(1),
            details: `N=${numericResponses.length} respostas`,
            distribution: countDistribution(numericResponses),
            startLabel: question.startLabel,
            endLabel: question.endLabel,
          });
        }
      } else if (qType === "multipleChoice") {
        // For multipleChoice, answers may be arrays or single values
        // Flatten all answers (if arrays) into a single array
        const allChoices: any[] = [];
        for (const ans of questionAnswers) {
          if (Array.isArray(ans)) {
            allChoices.push(...ans);
          } else {
            allChoices.push(ans);
          }
        }
        const distribution = countDistribution(allChoices);
        if (Object.keys(distribution).length) {
          const mode = Object.entries(distribution).reduce(
            (a: any, b: any) => (b[1] > a[1] ? b : a),
            ["", 0]
          )[0];
          survey_kpis.push({
            metric: question.questionText,
            value: mode,
            details: `N=${questionAnswers.length} respostas`,
            distribution: distribution,
          });
        }
      }
    }

    // 3. Monta outputData padronizado
    return {
      responseCount: responses.length,
      is_active,
      surveyStructure: surveyStructureToUse,
      outputData: {
        survey_results: { submissions: responses },
        survey_structure: surveyStructureToUse,
        survey_kpis,
      },
      updated_at: new Date().toISOString(),
      processInputError: null,
    };
  },

  async generateOutput(
    currentNode: TaskFlowNode
  ): Promise<Record<string, any>> {
    if (!currentNode.data.surveyId) {
      return {};
    }
    // Just return the entire outputData object that was calculated by processInput.
    // It ensures that survey_results, survey_structure, AND survey_kpis are all included.
    return currentNode.data.outputData || {};
  },

  getDisplayData(currentNode: TaskFlowNode): any {
    return {
      title: currentNode.data.title,
      surveyId: currentNode.data.surveyId,
      questionCount: currentNode.data.surveyStructure?.length || 0,
      responseCount: currentNode.data.responseCount || 0,
    };
  },

  async handleAction(
    action: string,
    payload: any,
    currentNode: TaskFlowNode, // <<< FIX: Use TaskFlowNode type
    fetchInstance: typeof $fetch // Match INodeHandler signature
  ): Promise<
    Partial<NodeData> | void | { error?: string; [key: string]: any }
  > {
    // Match INodeHandler signature
    // Return type updated to match INodeHandler
    // ─── Normaliza surveyId para funcionar com NodeData OU TaskFlowNode ───
    const surveyIdNormalized: string | null =
      (currentNode as any)?.surveyId ??
      (currentNode as any)?.data?.surveyId ??
      null;

    if (action === "fetchSurveyStructure" && surveyIdNormalized) {
      try {
        const structureResp = await fetchInstance<SurveyStructureResponse>(
          `/api/surveys/${surveyIdNormalized}/questions`,
          {}
        );
        return {
          surveyStructure: structureResp?.questions || [],
          updated_at: new Date().toISOString(),
        };
      } catch (err: any) {
        console.error(
          `[surveyNodeHandler] error fetching structure for survey ${surveyIdNormalized}:`,
          err?.data || err?.message || err
        );
        return;
      }
    } else if (action === "fetchSurveyStatus" && surveyIdNormalized) {
      // REFACTORED: Delegate directly to processInput to ensure all data is fetched and KPIs are calculated.
      // processInput needs parentOutputs, but for a survey node, these are not used for its internal state update.
      // It relies on its own surveyId. We can pass an empty object.
      // We also need to pass the fetch instance.
      try {
        // processInput needs the most up-to-date nodeData from the currentNode passed to handleAction
        const result = await this.processInput(
          currentNode.data,
          {},
          fetchInstance
        );
        return result;
      } catch (err: any) {
        console.error(
          `[surveyNodeHandler] fetchSurveyStatus (via processInput) error:`,
          err?.data || err?.message || err
        );
        return {
          processInputError: "Falha ao buscar status do survey.",
          updated_at: new Date().toISOString(),
        };
      }
    } else if (action === "initializeSurvey") {
      // This action should be called by the store after the node is added

      let updatedData = { ...currentNode.data }; // Start with current data

      // Scenario 1: No surveyId AND problem_definition exists (AI generation)
      let justCreatedSurveyId: string | undefined = undefined;
      let setIsActiveFromSurvey: boolean = false;
      if (!updatedData.surveyId && payload?.context?.problem_definition) {
        // Attempting AI survey generation based on problem_definition
        try {
          const generationPayload = {
            problem_statement: payload.context.problem_definition,
            context: payload.context, // Pass full context
          };
          const surveyResp = await $fetch<SurveyGenerationResponse>(
            "/api/ai/surveyGeneration",
            { method: "POST", body: generationPayload }
          );

          if (surveyResp?.survey_id) {
            updatedData.surveyId = surveyResp.survey_id;
            updatedData.title = surveyResp.title || updatedData.title;
            updatedData.updated_at = new Date().toISOString();
            justCreatedSurveyId = surveyResp.survey_id;
            setIsActiveFromSurvey = true;
            // AI Generation successful
            // Fetch structure for the newly AI-generated survey
            const nodeForStructureFetch: TaskFlowNode = {
              ...currentNode,
              data: updatedData,
            };
            const structureUpdate = await surveyNodeHandler.handleAction!(
              "fetchSurveyStructure",
              {},
              nodeForStructureFetch,
              fetchInstance // Pass fetchInstance
            );
            if (
              structureUpdate &&
              typeof structureUpdate === "object" &&
              !("error" in structureUpdate && structureUpdate.error) // Ensure no error before merging
            ) {
              // Merge Partial<NodeData> into existing NodeData
              updatedData = {
                ...updatedData,
                ...(structureUpdate as Partial<NodeData>),
              };
            }
          } else {
            console.warn(
              "[surveyNodeHandler] AI Survey generation failed: No survey_id returned."
            ); // Roo Log
            // useNuxtApp().$toast.error("Survey generation failed: No ID returned.");
          }
        } catch (err: any) {
          console.error(
            "[surveyNodeHandler initializeSurvey] API Error during AI survey generation:",
            err?.data || err?.message || err
          );
          // useNuxtApp().$toast.error(`Survey generation failed: ${err?.data?.message || err?.message || 'Unknown error'}`);
        }
        // Scenario 2: No surveyId AND task_id exists (Manual creation)
      } else if (!updatedData.surveyId && payload?.context?.task_id) {
        // Attempting manual survey creation with task_id
        try {
          // Call the endpoint to create a blank survey with default blocks
          const creationPayload = { task_id: payload.context.task_id };
          // The API /api/surveys (POST) returns { survey: { id: '...', ... } }
          const creationResp = await $fetch<{
            survey: { id: string; title?: string; task_id?: string };
          }>("/api/surveys", { method: "POST", body: creationPayload }); // Define expected response

          if (creationResp?.survey?.id) {
            updatedData.surveyId = creationResp.survey.id;
            // The API /api/surveys doesn't set a title, so we keep the existing or default.
            // updatedData.title = creationResp.survey.title || updatedData.title;
            updatedData.updated_at = new Date().toISOString();
            justCreatedSurveyId = creationResp.survey.id;
            setIsActiveFromSurvey = true;
            // Manual survey creation successful

            // Now fetch the structure (which will include default intro/thanks blocks)
            const nodeForStructureFetch: TaskFlowNode = {
              ...currentNode,
              data: updatedData,
            };
            const structureUpdate = await surveyNodeHandler.handleAction!(
              "fetchSurveyStructure",
              {},
              nodeForStructureFetch,
              fetchInstance // Pass fetchInstance
            );
            if (
              structureUpdate &&
              typeof structureUpdate === "object" &&
              !("error" in structureUpdate && structureUpdate.error) // Ensure no error before merging
            ) {
              // Merge Partial<NodeData> into existing NodeData
              updatedData = {
                ...updatedData,
                ...(structureUpdate as Partial<NodeData>),
              };
            }
          } else {
            console.warn(
              "[surveyNodeHandler] Manual survey creation failed: No survey.id returned from API."
            ); // Roo Log
            // useNuxtApp().$toast.error("Manual survey creation failed: No ID returned.");
          }
        } catch (err: any) {
          console.error(
            "[surveyNodeHandler initializeSurvey] API Error during manual survey creation:",
            err?.data || err?.message || err
          );
          // useNuxtApp().$toast.error(`Manual survey creation failed: ${err?.data?.message || err?.message || 'Unknown error'}`);
        }
        // Scenario 3: surveyId exists, but no surveyStructure (Fetch existing structure)
      } else if (updatedData.surveyId && !updatedData.surveyStructure) {
        // If surveyId exists but structure doesn't, fetch it

        // <<< FIX: Pass the full currentNode object but with updated data merged in
        const nodeForStructureFetch: TaskFlowNode = {
          ...currentNode,
          data: updatedData,
        };
        const structureUpdate = await surveyNodeHandler.handleAction!(
          // Add ! assertion
          // Use surveyNodeHandler instead of this
          "fetchSurveyStructure",
          {},
          nodeForStructureFetch, // <<< FIX: Pass TaskFlowNode
          fetchInstance // Pass fetchInstance
        );
        // Check if structureUpdate is valid NodeData before assigning
        if (
          structureUpdate &&
          typeof structureUpdate === "object" &&
          !("error" in structureUpdate && structureUpdate.error) // Ensure no error before merging
        ) {
          // Merge Partial<NodeData> into existing NodeData
          updatedData = {
            ...updatedData,
            ...(structureUpdate as Partial<NodeData>),
          }; // Merge structure update if successful
        }
      } else {
        // Conditions for AI generation, manual creation, or fetching structure not met
      }

      // After survey creation (AI or manual), fetch the full survey data to get is_active
      if (setIsActiveFromSurvey && justCreatedSurveyId) {
        // Define an interface for the expected survey data structure
        interface SurveyData {
          id: string;
          created_at: string;
          user_id: string;
          task_id: string | null;
          is_active: boolean;
        }

        try {
          // Fetch the full survey object and cast it to SurveyData
          const surveyData = (await fetchInstance(
            `/api/surveys/${justCreatedSurveyId}`
          )) as SurveyData | null; // Add null to the type if fetchInstance can return null
          updatedData.is_active = surveyData?.is_active ?? false;
        } catch (err) {
          console.error("Error fetching survey data to update is_active:", err); // Roo Log
          updatedData.is_active = false;
        }
      }

      // Regenerate output after initialization attempt
      // <<< FIX: Pass the full currentNode object but with updated data merged in
      const nodeForOutputGen: TaskFlowNode = {
        ...currentNode,
        data: updatedData,
      };
      const outputResult = await surveyNodeHandler.generateOutput!(
        // Renamed to avoid conflict
        nodeForOutputGen // <<< FIX: Pass TaskFlowNode
      ); // Add ! assertion
      updatedData.outputData = outputResult || {}; // Handle null case
      // Return each key only if present (including explicit undefined)
      const result: Partial<NodeData> = {
        surveyId: updatedData.surveyId,
        is_active: updatedData.is_active,
        updated_at: updatedData.updated_at,
        isLoadingEdgeConnection: false,
      };
      if ("title" in updatedData) result.title = updatedData.title;
      if ("surveyStructure" in updatedData)
        result.surveyStructure = updatedData.surveyStructure;
      if ("outputData" in updatedData)
        result.outputData = updatedData.outputData;
      return result;
    } else if (action === "setSurveyId") {
      // Action to manually set or change the survey ID
      if (payload.surveyId && typeof payload.surveyId === "string") {
        let updatedData: NodeData = {
          ...currentNode.data,
          surveyId: payload.surveyId,
          surveyStructure: undefined,
          outputData: {},
          updated_at: new Date().toISOString(),
        };
        // Attempt to fetch structure for the new ID
        const nodeForStructureFetch: TaskFlowNode = {
          ...currentNode,
          data: updatedData,
        };
        const structureUpdate = await surveyNodeHandler.handleAction!(
          "fetchSurveyStructure",
          {},
          nodeForStructureFetch,
          fetchInstance
        );
        if (
          structureUpdate &&
          typeof structureUpdate === "object" &&
          !("error" in structureUpdate && structureUpdate.error)
        ) {
          updatedData = {
            ...updatedData,
            ...(structureUpdate as Partial<NodeData>),
          };
        }
        // After setting surveyId, fetch the survey data to get is_active
        interface SurveyDataForSetId {
          id: string;
          created_at: string;
          user_id: string;
          task_id: string | null;
          is_active: boolean;
        }
        try {
          const surveyData = (await fetchInstance(
            `/api/surveys/${payload.surveyId}`
          )) as SurveyDataForSetId | null;
          updatedData.is_active = surveyData?.is_active ?? false;
        } catch (err) {
          console.error(
            `Error fetching survey data for ID ${payload.surveyId} in setSurveyId:`,
            err
          );
          updatedData.is_active = false;
        }
        const nodeForOutputGen: TaskFlowNode = {
          ...currentNode,
          data: updatedData,
        };
        const outputResult = await surveyNodeHandler.generateOutput!(
          nodeForOutputGen
        );
        updatedData.outputData = outputResult || {};
        const result: Partial<NodeData> = {
          surveyId: updatedData.surveyId,
          is_active: updatedData.is_active,
          updated_at: updatedData.updated_at,
          isLoadingEdgeConnection: false,
        };
        if ("surveyStructure" in updatedData)
          result.surveyStructure = updatedData.surveyStructure;
        if ("outputData" in updatedData)
          result.outputData = updatedData.outputData;
        return result;
      } else {
        console.warn(
          "[surveyNodeHandler setSurveyId] Invalid or missing surveyId in payload."
        );
      }
    }
    // --- NOVO FLUXO: Geração de survey via sistema de análise genérico ---
    else if (action === "generateSurvey") {
      try {
        const surveyId = currentNode.data.surveyId;
        if (!surveyId) {
          throw new Error(
            "ID do Survey não encontrado no nó para gerar a estrutura com IA."
          );
        }

        // 1. Preparar o payload para a API genérica.
        const apiPayload = {
          analysisKey: "generateSurvey",
          nodeData: currentNode.data,
        };

        // 2. Chamar a API genérica via fetchInstance ($fetch).
        const analysisResult = (await fetchInstance("/api/ai/runAnalysis", {
          method: "POST",
          body: apiPayload,
        })) as {
          processInputError?: string;
          outputData?: {
            generatedSurvey?: any;
          };
          analyzedData?: {
            surveyStructure?: any;
          };
        };

        if (analysisResult.processInputError) {
          throw new Error(analysisResult.processInputError);
        }

        // --- NOVA LÓGICA DE DETECÇÃO DE ESTRUTURA GERADA ---
        let generatedStructure: any[] | undefined;
        const generatedSurveyObject =
          analysisResult.outputData?.generatedSurvey;

        // Check if the AI returned { "surveyStructure": [...] } or just [...]
        if (Array.isArray(generatedSurveyObject)) {
          // AI returned the array directly inside 'generatedSurvey'
          generatedStructure = generatedSurveyObject;
        } else if (
          generatedSurveyObject &&
          Array.isArray(generatedSurveyObject.surveyStructure)
        ) {
          // AI returned the expected object wrapper { surveyStructure: [...] }
          generatedStructure = generatedSurveyObject.surveyStructure;
        } else if (
          generatedSurveyObject?.properties?.surveyStructure?.items &&
          Array.isArray(generatedSurveyObject.properties.surveyStructure.items)
        ) {
          // FIX: AI returned a schema with the data nested inside properties.surveyStructure.items
          generatedStructure =
            generatedSurveyObject.properties.surveyStructure.items;
        }

        if (
          !generatedStructure ||
          !Array.isArray(generatedStructure) ||
          generatedStructure.length === 0
        ) {
          throw new Error(
            `A IA não retornou uma estrutura de survey válida. Resposta recebida: ${JSON.stringify(
              analysisResult
            )}`
          );
        }
        // --- FIM DA NOVA LÓGICA ---

        // 4. Salvar a estrutura no banco de dados via RPC
        const supabase = useSupabaseClient();
        const { error: rpcError } = await supabase.rpc(
          "update_survey_structure",
          {
            p_survey_id: surveyId,
            p_survey_structure: generatedStructure,
          }
        );

        if (rpcError) {
          throw new Error(
            `Falha ao salvar a estrutura no banco de dados: ${rpcError.message}`
          );
        }

        // 5. Buscar a estrutura recém-salva para obter os IDs e a ordem correta do banco
        const { data: savedStructure, error: fetchError } = await supabase
          .from("questions")
          .select("*")
          .eq("survey_id", surveyId)
          .order("order", { ascending: true });

        if (fetchError) {
          throw new Error(
            `Falha ao buscar a estrutura salva: ${fetchError.message}`
          );
        }

        // 6. Retornar a estrutura salva para atualizar o estado do nó na store
        return {
          surveyStructure: savedStructure || [],
          processInputError: null, // Limpa qualquer erro anterior
          updated_at: new Date().toISOString(),
        };
      } catch (error: any) {
        console.error("[surveyNodeHandler][generateSurvey] Erro:", error);
        return {
          processInputError: `Falha na geração do survey: ${error.message}`,
        };
      }
    }
    // Handle other actions like 'deleteSurvey', 'updateSurveySettings', etc.
  },
};
